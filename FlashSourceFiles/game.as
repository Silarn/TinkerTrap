package  {		import flash.display.MovieClip;	import flash.ui.Keyboard;	import flash.events.KeyboardEvent;	import flash.events.Event;	import flash.text.TextField;	import flash.text.TextFormat;		public class game extends MovieClip {				//our map is 2-dimensional array		//map tiles: 0 = generic floor, 1 = generic wall, 2 = pressure plate, 3 = down-right switch,		//			 4 = down-right door, 5 = down-left door, 6 = down-left switch, 7 = bottom edge wall		//           8 = victory				//locations of objects		private var obsMap: Array = 		[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]];		//locations of map tiles		private var map: Array = 			[[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 7], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7], [1, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 7], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7], [1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7], [1, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 7], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7], [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 7], [1, 1, 1, 1, 1, 5, 1, 1, 3, 1, 1, 7], [1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 7], [1, 1, 1, 0, 1, 1, 1, 1, 2, 1, 1, 7], [1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 7], [1, 1, 1, 0, 4, 0, 0, 0, 0, 1, 1, 7], [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 7], [1, 1, 1, 2, 1, 1, 1, 1, 5, 1, 1, 7], [1, 1, 1, 0, 0, 4, 0, 0, 0, 1, 1, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]];		//tile connectons		private var connectionMap: Array = 	[[[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [13], [12,13], [11,12], [10,11], [9,10], [8,9], [7,8], [6,7], [5,6], [4,5], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [4], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [2], [0], [0], [1], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [3], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [1], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [2], [0], [0], [0], [0], [3], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [1], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]]];		//tile locks		private var locksMap: Array =		[[[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 //[[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [3], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [3], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [1], [0], [0], [2], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [1,2], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [1], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],											 [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]]];		//declare game playerject that holds info		private var gameB: Object = new Object();		private var gameBCon: Object = new Object();		private var gameBLock: Object = new Object();		private var gameBObs: Array = new Array();		private var tileW: int = 30;				private var player = new obstacle(1);				private var keyPressed: Array = new Array();				public function game() {						stage.addEventListener(KeyboardEvent.KEY_DOWN, keyHandler);			stage.addEventListener(KeyboardEvent.KEY_UP, clearKeys);			stage.addEventListener(Event.ENTER_FRAME, frameHandler);			//make the map						buildMap();			stop();		}				//building the world		function buildMap()		{			//get map dimensions			var mapWidth: int = map[0].length;			var mapHeight: int = map.length;						//loop to place tiles on stage			for (var i: int = 0; i<mapHeight; ++i)			{				for (var j: int = 0; j<mapWidth; ++j)				{					//name of new tile					var squareName: String = "t_"+i+"_"+j;					//make new tile playerject in the game					gameB[squareName] = new tile(map[i][j], j, i);					if (gameB[squareName].walkable)						gameB[squareName].depth = (j+i-.99)*tileW/2*300+(j-i)*tileW+1;					else						gameB[squareName].depth = (j+i)*tileW/2*300+(j-i)*tileW+1;					var insertDepth: int = -1;					for (var k: int = 0; k<numChildren; ++k) {						if (gameB[squareName].walkable) {							if (tile(getChildAt(k)).walkable)								insertDepth = k;						} else if (tile(getChildAt(k)).depth < gameB[squareName].depth) {							insertDepth = k;						}					}					if (insertDepth == numChildren)						addChild(gameB[squareName]);					else						addChildAt(gameB[squareName], insertDepth+1);					gameB[squareName].xiso = (j-i)*tileW;					gameB[squareName].yiso = (j+i)*tileW/2;										for (k = 0; k < connectionMap[i][j].length; k++) {					    if (connectionMap[i][j][0] != 0) {                            if (gameBCon[String(connectionMap[i][j][k])] == null) {                                gameBCon[String(connectionMap[i][j][k])] = new Array();                            }                            gameBCon[String(connectionMap[i][j][k])].push(gameB[squareName]);						}                        gameB[squareName].setConnection(connectionMap[i][j][k]);					}										for (k = 0; k < locksMap[i][j].length; k++) {					    if (locksMap[i][j][0] != 0) {                            if (gameBLock[String(locksMap[i][j][k])] == null) {                                gameBLock[String(locksMap[i][j][k])] = new Array();                            }                            gameBLock[String(locksMap[i][j][k])].push(gameB[squareName]);						}                        gameB[squareName].setLock(locksMap[i][j][k]);					}										if (obsMap[i][j] != 0) {						switch (obsMap[i][j]) {							case 1:								player.xtile = j;								player.ytile = i;								break;							case 2:								gameBObs.push(new obstacle(2));								gameBObs[gameBObs.length-1].xtile = j;								gameBObs[gameBObs.length-1].ytile = i;								break;						}					}				}			}						//calculate starting position			player.posX = player.xtile*tileW;			player.posY = player.ytile*tileW;			//calculate position in isometric view			player.xiso = player.posX-player.posY;			player.yiso = (player.posX+player.posY)/2;			//calculate the tile where players center is			player.xtile = Math.floor(player.posX/tileW);			player.ytile = Math.floor(player.posY/tileW);			//calculate depth			player.depthshift = (tileW-player.width/2)/2;			player.depth = (player.yiso-player.depthshift)*300+player.xiso+1;			//add the playeracter mc and insert at correct layer			insertDepth = 0;			for (i = 0; i < numChildren; ++i) {				if (tile(getChildAt(i)).depth <= player.depth)					insertDepth = i;			}			if (insertDepth == numChildren)				addChild(player);			else				addChildAt(player, insertDepth+1);						for (i = 0; i < gameBObs.length; i++) {				gameBObs[i].posX = gameBObs[i].xtile*tileW;				gameBObs[i].posY = gameBObs[i].ytile*tileW;				gameBObs[i].xiso = gameBObs[i].posX-gameBObs[i].posY;				gameBObs[i].yiso = (gameBObs[i].posX+gameBObs[i].posY)/2;				gameBObs[i].xtile = Math.floor(gameBObs[i].posX/tileW);				gameBObs[i].ytile = Math.floor(gameBObs[i].posY/tileW);				gameBObs[i].depthshift = (tileW-gameBObs[i].width/2)/2;				gameBObs[i].depth = (gameBObs[i].yiso-gameBObs[i].depthshift)*300+gameBObs[i].xiso+1;								for (j = 0; j < numChildren; ++j) {					var testDepth: Number;					if (getChildAt(j) is tile) {						testDepth = tile(getChildAt(j)).depth;					} else if (getChildAt(j) is obstacle) {						testDepth = obstacle(getChildAt(j)).depth;					}					if (testDepth <= gameBObs[i].depth)						insertDepth = j;				}								if (insertDepth == numChildren)					addChild(gameBObs[i]);				else					addChildAt(gameBObs[i], insertDepth+1);			}			camShift();		}				function camShift()		{			var offsetX: Number = stage.stageWidth/2-player.xiso;			var offsetY: Number = stage.stageHeight/2-player.yiso;			for (var i: int = 0; i < numChildren; i++) {				if (getChildAt(i) is tile) {					getChildAt(i).x = tile(getChildAt(i)).xiso+offsetX;					getChildAt(i).y = tile(getChildAt(i)).yiso+offsetY;				} else {					getChildAt(i).x = obstacle(getChildAt(i)).xiso+offsetX;					getChildAt(i).y = obstacle(getChildAt(i)).yiso+offsetY;				}			}		}				function getMyCorners(tob: obstacle, px: Number, py: Number)		{			tob.downYPos = py+tob.width/2-1;			tob.upYPos = py;			tob.leftXPos = px;			tob.rightXPos = px+tob.width/2-1;			//find corner points			tob.downY = Math.floor(tob.downYPos/tileW);			tob.upY = Math.floor(tob.upYPos/tileW);			tob.leftX = Math.floor(tob.leftXPos/tileW);			tob.rightX = Math.floor(tob.rightXPos/tileW);			//check if they are walls			tob.upleft = gameB["t_"+tob.upY+"_"+tob.leftX].walkable;			tob.downleft = gameB["t_"+tob.downY+"_"+tob.leftX].walkable;			tob.upright = gameB["t_"+tob.upY+"_"+tob.rightX].walkable;			tob.downright = gameB["t_"+tob.downY+"_"+tob.rightX].walkable;		}				function moveChar(tob: obstacle, speed: Number, dirx: int, diry: int): Number		{			//vertical movement			//where are our edges?			//first we look for y movement, so x is old			//move got dammit... and check for collisions.			//going up						var speedAdj: Number = speed;						getMyCorners(tob, tob.posX, tob.posY+speed*diry);									if (diry == -1)			{				if (tob.upleft && tob.upright)				{					for (var i: int = 0; i < gameBObs.length; i++) {						if (gameBObs[i] != tob) {							getMyCorners(gameBObs[i], gameBObs[i].posX, gameBObs[i].posY);							if (Math.abs((gameBObs[i].upYPos+gameBObs[i].downYPos)/2 -								 (tob.upYPos+tob.downYPos-1)/2) < (gameBObs[i].width+tob.width)/4 &&								tob.xtile == gameBObs[i].xtile) {								speedAdj = moveChar(gameBObs[i], speed/2, dirx, diry);							}						}					}					tob.posY += speedAdj*diry;				}				else				{					//hit the wall, place tob near the wall					tob.posY = tob.ytile*tileW;					speedAdj = 0;				}			}			//if going down			if (diry == 1)			{				if (tob.downleft && tob.downright)				{					for (i = 0; i < gameBObs.length; i++) {						if (gameBObs[i] != tob) {							getMyCorners(gameBObs[i], gameBObs[i].posX, gameBObs[i].posY);							if (Math.abs((gameBObs[i].upYPos+gameBObs[i].downYPos)/2 -								 (tob.upYPos+tob.downYPos-1)/2) <  (gameBObs[i].width+tob.width)/4 &&								tob.xtile == gameBObs[i].xtile) {								speedAdj = moveChar(gameBObs[i], speed/2, dirx, diry);							}						}					}					tob.posY += speedAdj*diry;				}				else				{					tob.posY = (tob.ytile+1)*tileW-tob.width/2;					speedAdj = 0;				}			}			//horisontal movement			//changing x with speed and taking old y			getMyCorners(tob, tob.posX+speed*dirx, tob.posY);			//if going left			if (dirx == -1)			{				if (tob.downleft && tob.upleft)				{					for (i = 0; i < gameBObs.length; i++) {						if (gameBObs[i] != tob) {							getMyCorners(gameBObs[i], gameBObs[i].posX, gameBObs[i].posY);							if (Math.abs((gameBObs[i].leftXPos+gameBObs[i].rightXPos)/2 -								 (tob.leftXPos+tob.rightXPos-1)/2) <  (gameBObs[i].width+tob.width)/4 &&								tob.ytile == gameBObs[i].ytile) {								speedAdj = moveChar(gameBObs[i], speed/2, dirx, diry);							}						}					}					tob.posX += speedAdj*dirx;				}				else				{					tob.posX = tob.xtile*tileW;					speedAdj = 0;				}			}			//if going right			if (dirx == 1)			{				if (tob.upright && tob.downright)				{					for (i = 0; i < gameBObs.length; i++) {						if (gameBObs[i] != tob) {							getMyCorners(gameBObs[i], gameBObs[i].posX, gameBObs[i].posY);							if (Math.abs((gameBObs[i].leftXPos+gameBObs[i].rightXPos)/2 -								 (tob.leftXPos+tob.rightXPos-1)/2) <  (gameBObs[i].width+tob.width)/4 &&								tob.ytile == gameBObs[i].ytile) {								speedAdj = moveChar(gameBObs[i], speed/2, dirx, diry);							}						}					}					tob.posX += speedAdj*dirx;				}				else				{					tob.posX = (tob.xtile+1)*tileW-tob.width/2;					speedAdj = 0;				}			}			//calculate position in isometric view			tob.xiso = tob.posX-tob.posY;			tob.yiso = (tob.posX+tob.posY)/2;			//update tob position			tob.x = tob.xiso;			tob.y = tob.yiso;			//face the direction			tob.setFacing(dirx+diry*2+3);			//calculate the tile where tobs center is			tob.xtile = Math.floor(tob.posX/tileW);			tob.ytile = Math.floor(tob.posY/tileW);			//calculate depth			tob.depth = (tob.yiso-tob.depthshift)*300+(tob.xiso)+1;						/*var insertDepth: int = 0;			for (var i: int = 0; i < numChildren; ++i) {				if (i != getChildIndex(tob)) {					var testDepth: Number;					if (getChildAt(i) is tile) {						testDepth = tile(getChildAt(i)).depth;					} else if (getChildAt(i) is obstacle) {						testDepth = obstacle(getChildAt(i)).depth;					}					if (testDepth <= tob.depth)						insertDepth = i;				}			}						if (getChildIndex(tob) != insertDepth+1) {				if (getChildIndex(tob) < insertDepth) {					setChildIndex(tob, insertDepth);				} else {					setChildIndex(tob, insertDepth+1);				}			}*/			return (speedAdj);		}				function interact(): void {			var inTile: tile;			var interactGroup: Array;			if (player.currDir == 0) {				inTile = gameB["t_"+String(player.ytile-1)+"_"+String(player.xtile)];			}			if (player.currDir == 1) {				inTile = gameB["t_"+String(player.ytile)+"_"+String(player.xtile+1)];			}			if (player.currDir == 2) {				inTile = gameB["t_"+String(player.ytile+1)+"_"+String(player.xtile)];			}			if (player.currDir == 3) {				inTile = gameB["t_"+String(player.ytile)+"_"+String(player.xtile-1)];			}						if (inTile.lockGroup[0] != 0) {				for (var i: int = 0; i < inTile.lockGroup.length; i++) {					for (var j: int = 0; j < gameBLock[String(inTile.lockGroup[i])].length; j++) {						if (gameBLock[String(inTile.lockGroup[i])][j].locked)							return;					}				}			}						interactGroup = inTile.interact();						if (interactGroup != null) {				for (i = 0; i < interactGroup.length; i++) {					for (j = 0; j < gameBCon[String(interactGroup[i])].length; j++) {						gameBCon[String(interactGroup)][j].used = true;					}				}			}		}				function keyHandler(evt: KeyboardEvent): void {			if (keyPressed.indexOf(evt.keyCode) == -1)				keyPressed.push(evt.keyCode);							if (evt.keyCode == Keyboard.SPACE) {				interact();			}		}				function clearKeys(evt: KeyboardEvent): void {			keyPressed.splice(keyPressed.indexOf(evt.keyCode),1);		}				function layerOrder(): void {						for (var i: int = 0; i < numChildren; i++) {				var insertDepth: int = -1;				if (getChildAt(i) is tile) {					for (var j: int = 0; j < numChildren; j++) {						var testDepth: Number;						if (getChildAt(j) is tile) {							testDepth = tile(getChildAt(j)).depth;						} else if (getChildAt(j) is obstacle) {							testDepth = obstacle(getChildAt(j)).depth;						}						if (testDepth <= tile(getChildAt(i)).depth)							insertDepth = j;					}				} else {					for (j = 0; j < numChildren; j++) {						if (getChildAt(j) is tile) {							testDepth = tile(getChildAt(j)).depth;						} else if (getChildAt(j) is obstacle) {							testDepth = obstacle(getChildAt(j)).depth;						}						if (testDepth <= obstacle(getChildAt(i)).depth)							insertDepth = j;					}				}								if (i != insertDepth) {					if (i < insertDepth) {						setChildIndex(getChildAt(i), insertDepth);					} else {						setChildIndex(getChildAt(i), insertDepth+1);					}				}			}		}				function frameHandler(evt: Event): void		{			if (keyPressed.indexOf(Keyboard.BACKSLASH) != -1) {				reset();			}			else if (keyPressed.indexOf(Keyboard.RIGHT) != -1)			{				moveChar(player, 5.0, 1, 0);				player.currDir = 1;			}			else if (keyPressed.indexOf(Keyboard.LEFT) != -1)			{				moveChar(player, 5.0, -1, 0);				player.currDir = 3;			}			else if (keyPressed.indexOf(Keyboard.UP) != -1)			{				moveChar(player, 5.0, 0, -1);				player.currDir = 0;			}			else if (keyPressed.indexOf(Keyboard.DOWN) != -1)			{				moveChar(player, 5.0, 0, 1);				player.currDir = 2;			}						// Actions when the player actively walks over tiles.            switch (gameB["t_"+player.ytile+"_"+player.xtile].type) {                case 8:                    victory();                    break;            }						// Tile listener, checks all objects to perform actions.						var interactGroup: Array;						var objArray: Array = gameBObs.concat();			objArray.push(player);						var alltiles: Array = new Array();			for (var i: int = 0; i < numChildren; i++) {			    if (getChildAt(i) is tile) {			        alltiles.push(tile(getChildAt(i)));			    }			}						for (i = 0; i < alltiles.length; i++) {                interactGroup = alltiles[i].act(objArray);                if (interactGroup != null) {                    for (var j: int = 0; j < interactGroup.length; j++) {                        if (interactGroup[0] != 0) {                            for (var k: int = 0; k < gameBCon[String(interactGroup[j])].length; k++) {                                var isLocked: Boolean = false;                                for (var l: int = 0; l < gameBCon[String(interactGroup[j])][k].lockGroup.length; l++) {                                    if (gameBCon[String(interactGroup[j])][k].lockGroup[0] != 0) {                                        for (var m: int = 0; m < gameBLock[String(gameBCon[String(interactGroup[j])][k].lockGroup[l])].length; m++) {                                            if (gameBLock[String(gameBCon[String(interactGroup[j])][k].lockGroup[l])][m].locked)                                                isLocked = true;                                        }                                    }                                }                                if (!isLocked) {                                    gameBCon[String(interactGroup[j])][k].used = true;                                    if (gameBCon[String(interactGroup[j])][k].wait == 0) {                                        var numCons: int = 0;                                        for (l = 0; l < gameBCon[String(interactGroup[j])][k].connection.length; l++) {                                            if (gameBCon[String(interactGroup[j])][k].connection[l] != 0)                                                numCons += gameBCon[String(gameBCon[String(interactGroup[j])][k].connection[l])].length;                                        }                                        gameBCon[String(interactGroup[j])][k].nextWait = numCons - gameBCon[String(interactGroup[j])][k].connection.length;                                    }                                }                            }                        }                    }                }			}						layerOrder();			camShift();		}				function victory(): void {		    while (numChildren > 0) {		        removeChildAt(0);		    }						stage.removeEventListener(KeyboardEvent.KEY_DOWN, keyHandler);			stage.removeEventListener(KeyboardEvent.KEY_UP, clearKeys);			stage.removeEventListener(Event.ENTER_FRAME, frameHandler);			stage.addEventListener(KeyboardEvent.KEY_DOWN, resetNow);						var vic: TextField = new TextField();			var vicf: TextFormat = new TextFormat();			vic.x = stage.stageWidth/2-vic.width/2;			vic.y = stage.stageHeight/2;						vicf.size = 20;						vic.defaultTextFormat = vicf;			vic.text = "You win! For now.";			vic.wordWrap = true;			vic.textColor = 0xFFFFFF;						addChild(vic);		}				function resetNow(evt: KeyboardEvent): void {			stage.removeEventListener(KeyboardEvent.KEY_DOWN, resetNow);			reset();		}				function reset(): void {		    while (numChildren > 0) {		        removeChildAt(0);		    }						gameB = new Object();			gameBCon = new Object();			gameBLock = new Object();			gameBObs = new Array();						buildMap();		}	}}